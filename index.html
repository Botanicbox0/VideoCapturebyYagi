<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>비디오 프레임 캡처 도구</title>
    <meta name="description" content="무료 비디오 프레임 캡처 도구 - 영상에서 원하는 간격으로 이미지를 쉽게 추출하세요">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎬</text></svg>">
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef } = React;

        function VideoFrameCapture() {
            const [videoUrl, setVideoUrl] = useState(null);
            const [videoFile, setVideoFile] = useState(null);
            const [intervalSeconds, setIntervalSeconds] = useState(0.5);
            const [frames, setFrames] = useState([]);
            const [isCapturing, setIsCapturing] = useState(false);
            const [selectedFrames, setSelectedFrames] = useState(new Set());
            const [videoDuration, setVideoDuration] = useState(0);
            const [captureProgress, setCaptureProgress] = useState(0);
            const [error, setError] = useState('');
            const [isDragging, setIsDragging] = useState(false);
            const [isDownloading, setIsDownloading] = useState(false);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);

            const handleVideoUpload = (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('video/')) {
                    processVideoFile(file);
                }
            };

            const processVideoFile = (file) => {
                const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
                console.log('Processing video file:', file.name, file.type, `${fileSizeMB}MB`);

                if (videoUrl) {
                    URL.revokeObjectURL(videoUrl);
                }
                
                const url = URL.createObjectURL(file);
                console.log('Created object URL:', url);
                
                setVideoUrl(url);
                setVideoFile(file);
                setFrames([]);
                setSelectedFrames(new Set());
                setError('');
                setCaptureProgress(0);
                setIsDragging(false);
                setVideoDuration(0);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);

                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    processVideoFile(file);
                } else {
                    setError('비디오 파일만 업로드 가능합니다.');
                }
            };

            const handleVideoLoad = (e) => {
                console.log('Video loadedmetadata event fired');
                const video = e.target;
                console.log('Video element:', {
                    duration: video.duration,
                    readyState: video.readyState,
                    videoWidth: video.videoWidth,
                    videoHeight: video.videoHeight
                });
                
                if (video.duration && !isNaN(video.duration) && video.duration > 0) {
                    setVideoDuration(video.duration);
                    setError('');
                    console.log('Video successfully loaded:', video.duration);
                }
            };

            const handleVideoCanPlay = (e) => {
                console.log('Video can play');
                const video = e.target;
                if (video.duration && videoDuration === 0) {
                    setVideoDuration(video.duration);
                    setError('');
                }
            };

            const handleVideoError = (e) => {
                const video = e.target;
                console.error('Video error:', video.error);
                
                let errorMessage = '비디오를 로드할 수 없습니다. ';
                if (video.error) {
                    switch (video.error.code) {
                        case 1: errorMessage += '다운로드가 중단되었습니다.'; break;
                        case 2: errorMessage += '네트워크 오류가 발생했습니다.'; break;
                        case 3: errorMessage += '비디오 디코딩 오류가 발생했습니다.'; break;
                        case 4: errorMessage += '지원하지 않는 비디오 형식입니다.'; break;
                        default: errorMessage += '알 수 없는 오류가 발생했습니다.';
                    }
                }
                setError(errorMessage);
            };

            const captureFrame = (currentTime) => {
                const video = videoRef.current;
                const canvas = canvasRef.current;
                
                if (!video || !canvas) return null;

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                return {
                    dataUrl: canvas.toDataURL('image/jpeg', 0.95),
                    timestamp: currentTime,
                    id: `frame_${Date.now()}_${Math.random()}`
                };
            };

            const captureAllFrames = async () => {
                const video = videoRef.current;
                if (!video || !video.duration) {
                    setError('비디오를 먼저 로드해주세요.');
                    return;
                }

                setIsCapturing(true);
                setError('');
                setFrames([]);
                setCaptureProgress(0);
                
                try {
                    const capturedFrames = [];
                    const duration = video.duration;
                    const totalFrames = Math.floor(duration / intervalSeconds);
                    let currentFrame = 0;
                    
                    video.currentTime = 0;
                    await new Promise(resolve => {
                        video.onseeked = resolve;
                    });

                    for (let time = 0; time < duration; time += intervalSeconds) {
                        try {
                            video.currentTime = Math.min(time, duration - 0.01);
                            
                            await new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => reject(new Error('Seek timeout')), 5000);
                                video.onseeked = () => {
                                    clearTimeout(timeout);
                                    resolve();
                                };
                            });

                            await new Promise(resolve => setTimeout(resolve, 50));
                            
                            const frame = captureFrame(time);
                            if (frame) {
                                capturedFrames.push(frame);
                                currentFrame++;
                                setCaptureProgress(Math.round((currentFrame / totalFrames) * 100));
                            }
                        } catch (err) {
                            console.warn('Frame capture failed at', time, err);
                        }
                    }
                    
                    if (capturedFrames.length === 0) {
                        setError('프레임 캡처에 실패했습니다. 다른 비디오로 시도해보세요.');
                    } else {
                        setFrames(capturedFrames);
                        console.log('Captured', capturedFrames.length, 'frames');
                    }
                } catch (err) {
                    setError('프레임 캡처 중 오류가 발생했습니다: ' + err.message);
                    console.error('Capture error:', err);
                } finally {
                    setIsCapturing(false);
                    setCaptureProgress(0);
                }
            };

            const toggleFrameSelection = (frameId) => {
                const newSelected = new Set(selectedFrames);
                if (newSelected.has(frameId)) {
                    newSelected.delete(frameId);
                } else {
                    newSelected.add(frameId);
                }
                setSelectedFrames(newSelected);
            };

            const selectAllFrames = () => {
                if (selectedFrames.size === frames.length) {
                    setSelectedFrames(new Set());
                } else {
                    setSelectedFrames(new Set(frames.map(f => f.id)));
                }
            };

            const downloadFrame = (frame) => {
                const link = document.createElement('a');
                link.href = frame.dataUrl;
                link.download = `frame_${frame.timestamp.toFixed(2)}s.jpg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const downloadAsZip = async (framesToDownload, zipName) => {
                setIsDownloading(true);
                try {
                    const zip = new JSZip();
                    
                    for (let i = 0; i < framesToDownload.length; i++) {
                        const frame = framesToDownload[i];
                        const base64Data = frame.dataUrl.split(',')[1];
                        const fileName = `frame_${String(i + 1).padStart(4, '0')}_${frame.timestamp.toFixed(2)}s.jpg`;
                        zip.file(fileName, base64Data, {base64: true});
                    }
                    
                    const content = await zip.generateAsync({type: 'blob'});
                    const url = URL.createObjectURL(content);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = zipName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                } catch (err) {
                    setError('ZIP 파일 생성 중 오류가 발생했습니다.');
                    console.error('ZIP error:', err);
                } finally {
                    setIsDownloading(false);
                }
            };

            const downloadSelected = () => {
                const selectedFramesList = frames.filter(f => selectedFrames.has(f.id));
                if (selectedFramesList.length > 1) {
                    downloadAsZip(selectedFramesList, 'selected_frames.zip');
                } else if (selectedFramesList.length === 1) {
                    downloadFrame(selectedFramesList[0]);
                }
            };

            const downloadAll = () => {
                if (frames.length > 1) {
                    downloadAsZip(frames, 'all_frames.zip');
                } else if (frames.length === 1) {
                    downloadFrame(frames[0]);
                }
            };

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = (seconds % 60).toFixed(2);
                return `${mins}:${secs.padStart(5, '0')}`;
            };

            const estimatedFrames = videoDuration ? Math.floor(videoDuration / intervalSeconds) : 0;

            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-900 via-gray-900 to-black text-white p-4 md:p-8">
                    <div className="max-w-7xl mx-auto">
                        <div className="mb-8">
                            <h1 className="text-3xl md:text-4xl font-bold mb-2">비디오 프레임 캡처</h1>
                            <p className="text-gray-400">영상에서 원하는 간격으로 프레임을 추출하세요</p>
                        </div>

                        <div className="bg-gray-800/50 backdrop-blur rounded-2xl p-4 md:p-8 mb-8 border border-gray-700">
                            {!videoUrl ? (
                                <div className="mb-6">
                                    <label 
                                        className={`flex items-center justify-center w-full h-64 border-2 border-dashed rounded-xl cursor-pointer transition-all ${
                                            isDragging 
                                                ? 'border-purple-500 bg-purple-500/10 scale-105' 
                                                : 'border-gray-600 hover:border-purple-500 bg-gray-900/30'
                                        }`}
                                        onDragOver={handleDragOver}
                                        onDragLeave={handleDragLeave}
                                        onDrop={handleDrop}
                                    >
                                        <input
                                            type="file"
                                            accept="video/*"
                                            onChange={handleVideoUpload}
                                            className="hidden"
                                        />
                                        <div className="text-center p-4">
                                            <svg className={`w-12 md:w-16 h-12 md:h-16 mx-auto mb-4 transition-colors ${isDragging ? 'text-purple-400' : 'text-gray-500'}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                                            </svg>
                                            <p className="text-lg md:text-xl mb-2">
                                                {isDragging ? '여기에 놓으세요!' : '비디오 파일을 드래그하거나 클릭하여 업로드'}
                                            </p>
                                            <p className="text-sm text-gray-500">MP4, MOV, WebM 등 지원</p>
                                        </div>
                                    </label>
                                </div>
                            ) : (
                                <>
                                    <div className="relative mb-6">
                                        <video
                                            ref={videoRef}
                                            src={videoUrl}
                                            onLoadedMetadata={handleVideoLoad}
                                            onCanPlay={handleVideoCanPlay}
                                            onError={handleVideoError}
                                            className="w-full rounded-lg bg-black max-h-96"
                                            controls
                                            preload="auto"
                                            playsInline
                                        />
                                        {videoDuration > 0 && (
                                            <div className="absolute top-2 left-2 bg-black/70 px-2 py-1 rounded text-xs">
                                                📹 {formatTime(videoDuration)} {videoFile && `| ${(videoFile.size / (1024 * 1024)).toFixed(1)}MB`}
                                            </div>
                                        )}
                                        <button
                                            onClick={() => {
                                                if (videoUrl) URL.revokeObjectURL(videoUrl);
                                                setVideoUrl(null);
                                                setVideoFile(null);
                                                setFrames([]);
                                                setSelectedFrames(new Set());
                                                setVideoDuration(0);
                                                setError('');
                                            }}
                                            className="absolute top-2 right-2 px-3 py-1 bg-red-600/80 hover:bg-red-600 rounded text-sm"
                                        >
                                            비디오 변경
                                        </button>
                                    </div>
                                    
                                    <div className="flex flex-col md:flex-row gap-4 items-end mb-6">
                                        <div className="flex-1 w-full">
                                            <label className="block text-sm font-medium mb-2">
                                                캡처 간격 (초)
                                            </label>
                                            <input
                                                type="number"
                                                value={intervalSeconds}
                                                onChange={(e) => setIntervalSeconds(Math.max(0.1, parseFloat(e.target.value) || 0.1))}
                                                min="0.1"
                                                step="0.1"
                                                className="w-full px-4 py-3 bg-gray-900 border border-gray-700 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-white"
                                                disabled={isCapturing}
                                            />
                                            <p className="text-xs text-gray-500 mt-1">
                                                {videoDuration > 0 ? (
                                                    <>총 예상 프레임: {estimatedFrames}개 (영상 길이: {formatTime(videoDuration)})</>
                                                ) : (
                                                    <span className="text-yellow-500">비디오를 로딩 중...</span>
                                                )}
                                            </p>
                                        </div>
                                        
                                        <button
                                            onClick={captureAllFrames}
                                            disabled={isCapturing || !videoDuration || videoDuration <= 0}
                                            title={!videoDuration ? '비디오가 로드될 때까지 기다려주세요' : ''}
                                            className="w-full md:w-auto px-6 md:px-8 py-3 bg-gradient-to-r from-purple-600 to-pink-600 rounded-lg font-semibold hover:from-purple-700 hover:to-pink-700 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                                        >
                                            {isCapturing ? (
                                                <>
                                                    <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                                                    캡처 중... {captureProgress}%
                                                </>
                                            ) : (
                                                <>
                                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                                    </svg>
                                                    프레임 캡처 시작
                                                </>
                                            )}
                                        </button>
                                    </div>

                                    {error && (
                                        <div className="bg-red-500/20 border border-red-500 rounded-lg p-4 text-red-200 mb-4">
                                            <p className="font-semibold mb-1">오류 발생</p>
                                            <p className="text-sm">{error}</p>
                                            <p className="text-xs mt-2 text-red-300">
                                                💡 팁: MP4 형식의 H.264 코덱 비디오를 권장합니다.
                                            </p>
                                        </div>
                                    )}
                                </>
                            )}
                        </div>

                        {frames.length > 0 && (
                            <div className="bg-gray-800/50 backdrop-blur rounded-2xl p-4 md:p-8 border border-gray-700">
                                <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
                                    <h2 className="text-xl md:text-2xl font-bold">
                                        캡처된 프레임 ({frames.length}개)
                                    </h2>
                                    <div className="flex flex-wrap gap-2 md:gap-3 w-full md:w-auto">
                                        <button
                                            onClick={selectAllFrames}
                                            className="flex-1 md:flex-none px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors flex items-center justify-center gap-2 text-sm"
                                        >
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                {selectedFrames.size === frames.length ? (
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
                                                ) : (
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                                                )}
                                            </svg>
                                            전체 선택
                                        </button>
                                        <button
                                            onClick={downloadSelected}
                                            disabled={selectedFrames.size === 0 || isDownloading}
                                            className="flex-1 md:flex-none px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 text-sm"
                                        >
                                            {isDownloading ? (
                                                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                                            ) : (
                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                                </svg>
                                            )}
                                            선택 다운로드 ({selectedFrames.size})
                                        </button>
                                        <button
                                            onClick={downloadAll}
                                            disabled={isDownloading}
                                            className="flex-1 md:flex-none px-4 py-2 bg-gradient-to-r from-purple-600 to-pink-600 rounded-lg hover:from-purple-700 hover:to-pink-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 text-sm"
                                        >
                                            {isDownloading ? (
                                                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                                            ) : (
                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                                </svg>
                                            )}
                                            전체 다운로드
                                        </button>
                                    </div>
                                </div>

                                {selectedFrames.size > 1 || frames.length > 1 ? (
                                    <div className="mb-4 p-3 bg-blue-500/20 border border-blue-500 rounded-lg text-blue-200 text-sm">
                                        💡 여러 프레임은 ZIP 파일로 다운로드됩니다
                                    </div>
                                ) : null}

                                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 md:gap-4">
                                    {frames.map((frame) => (
                                        <div
                                            key={frame.id}
                                            className={`relative group cursor-pointer rounded-lg overflow-hidden border-2 transition-all ${
                                                selectedFrames.has(frame.id)
                                                    ? 'border-purple-500 ring-2 ring-purple-500/50'
                                                    : 'border-gray-700 hover:border-gray-600'
                                            }`}
                                            onClick={() => toggleFrameSelection(frame.id)}
                                        >
                                            <img
                                                src={frame.dataUrl}
                                                alt={`Frame at ${formatTime(frame.timestamp)}`}
                                                className="w-full aspect-video object-cover"
                                            />
                                            <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity">
                                                <div className="absolute bottom-0 left-0 right-0 p-2">
                                                    <p className="text-xs md:text-sm font-semibold">{formatTime(frame.timestamp)}</p>
                                                </div>
                                            </div>
                                            {selectedFrames.has(frame.id) && (
                                                <div className="absolute top-2 right-2 bg-purple-600 rounded-full p-1">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                                                    </svg>
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        <canvas ref={canvasRef} className="hidden" />
                        
                        <footer className="mt-12 text-center text-gray-500 text-sm">
                            <p>Made by @Yagi_Workshop</p>
                        </footer>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<VideoFrameCapture />, document.getElementById('root'));
    </script>
</body>
</html>
